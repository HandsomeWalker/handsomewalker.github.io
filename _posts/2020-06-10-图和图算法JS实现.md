---
layout:     post
title:      图和图算法JS实现
subtitle:   dfs,bfs,最短路径
date:       2020-06-10
author:     HandsomeWalker
header-img: img/post-bg-js-version.jpg
catalog: true
tags:
    - 数据结构与算法
    - Javascript
---

## 邻接表
```javascript
[
  [1, 2],
  [0, 3],
  [0, 4],
  [1],
  [2]
]
```
## show me the code
```javascript
function Graph(v) {
  // 顶点数
  this.vertices = v;
  // 边数
  this.edges = 0;
  // 邻接表
  this.adj = [];
  for (var i = 0; i < this.vertices; i++) {
    this.adj[i] = [];
  }
}
Graph.prototype = {
  addEdge(v, w) {
    this.adj[v].push(w);
    this.adj[w].push(v);
    this.edges++;
  },
  // 深度优先搜索
  dfs(v) {
    if (this.adj[v] === undefined) {
      return;
    }
    var stack = [v];
    var visited = new Set();
    visited.add(v);
    while (stack.length) {
      var vertex = stack.pop();
      var nodes = this.adj[vertex];
      for (var w of nodes) {
        if (!visited.has(w)) {
          stack.push(w);
          visited.add(w);
        }
      }
      console.log('dfs:', vertex);
    }
  },
  // 广度优先搜索
  bfs(v) {
    if (this.adj[v] === undefined) {
      return;
    }
    var que = [v];
    var visited = new Set();
    visited.add(v);
    var parent = [];
    parent[v] = null;
    while (que.length) {
      var vertex = que.shift();
      var nodes = this.adj[vertex];
      for (var w of nodes) {
        if (!visited.has(w)) {
          que.push(w);
          visited.add(w);
          parent[w] = vertex;
        }        
      }
      console.log('bfs:', vertex);
    }
    return parent;
  },
  // 求两顶点间最短路径
  minPath(start, end) {
    var parent = this.bfs(start);
    var path = [];
    while (end !== null) {
      path.push(end);
      end = parent[end];
    }
    return path.reverse().join(' -> ');
  }
};
var g = new Graph(5);
g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 3);
g.addEdge(2, 4);
g.dfs(0);
g.minPath(0, 4);
```
